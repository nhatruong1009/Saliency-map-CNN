# -*- coding: utf-8 -*-
"""gradcam.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_HfRgmySzRjRn6pWdkcgMKFkV4h8jUtM
"""

def write_to_file_three_times(file_name, text):
    with open(file_name, "a") as f:
        f.write(text + "\n")
            
# Example usage
log_file = "/media/lhbac04/code/CAMProjectXAI/wget_log"
write_to_file_three_times(log_file, "log_file")
    
root_path = ".."


import torch
import torchvision.models as models
import torchvision.transforms as transforms
from PIL import Image
import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from pytorch_grad_cam import GradCAM, GradCAMPlusPlus, XGradCAM, EigenCAM
# , AblationCAM
from CAM.ablation_cam import AblationCAM
from CAM.score_cam import ScoreCAM
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget

write_to_file_three_times(log_file, "start model.eval()")
model = models.vgg16(pretrained=True)
model.eval()

write_to_file_three_times(log_file, "end model.eval()")

def input_link(name):
    img = Image.open(name).convert('RGB')
    preprocess = transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
    ])
    img_tensor = preprocess(img)
    return img_tensor.unsqueeze(0)

def predict_decode(yhat):
    probabilities = torch.softmax(yhat, dim=1)
    top5_prob_indices = torch.topk(probabilities, 5)[1].squeeze(0).tolist()

    with open("labels.txt") as f:
        labels = [line.strip() for line in f.readlines()]

    top5_labels = [(labels[i], probabilities[0, i].item()) for i in top5_prob_indices]
    for i in top5_labels:
        print(i)
    return (top5_labels[0], int(yhat.argmax()))

class Flatten(torch.nn.Module):
    def forward(self, x):
        x = torch.flatten(x, start_dim=1)
        return x

def generate_flat_model(model=model):
    new_model = torch.nn.Sequential(*(list(model.children())[0] + torch.nn.Sequential(model.avgpool) + torch.nn.Sequential(Flatten()) + list(model.children())[2]))
    layers = torch.nn.Sequential(*(list(new_model.children())))
    return layers

def show_cam_on_image(
    img: np.ndarray, mask: np.ndarray, use_rgb: bool = False,
    colormap: int = cv2.COLORMAP_JET, image_weight: float = 0.005) -> np.ndarray:
    heatmap = cv2.applyColorMap(np.uint8(255 * mask), colormap)
    if use_rgb:
        heatmap = cv2.cvtColor(heatmap, cv2.COLOR_BGR2RGB)
    heatmap = np.float32(heatmap) / 255
    cam = (1 - image_weight) * heatmap + image_weight * img
    cam = cam / np.max(cam)
    return np.uint16(255 * cam)

def cam_func(image, target_layers, cam_model):
    resized_img = cv2.resize(image, (224, 224))
    # Convert BGR to RGB (OpenCV loads images as BGR by default)
    image = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)
    cam = cam_model(model=model, target_layers=target_layers)
    grayscale_cam = cam(input_tensor=image_tensor, targets=None)
    grayscale_cam = grayscale_cam[0, :]
    visualization = show_cam_on_image(image, grayscale_cam, use_rgb=True)
    # model_outputs = cam.outputs
    # plt.imshow(visualization)
    # plt.show()
    return visualization

def visualization(img):
    plt.imshow(img)
    plt.show()

import os

write_to_file_three_times(log_file, "image path")
# Đường dẫn đến thư mục chứa các tệp
folder_path = f'{root_path}/dataset/ILSVRC2012'
file_names = [os.path.basename(file_path) for file_path in folder_path]

write_to_file_three_times(log_file, "CAM")

for i in range(50):
  image_path = f"{folder_path}/{file_names[i]}"
  image_tensor = input_link(image_path)
  yhat = model(image_tensor)
  result = predict_decode(yhat)
  label = result[1]
  print(result[0])
  target_layers = [model.features[-1]]
  targets = [ClassifierOutputTarget(label)]
  # Load the image
  img = cv2.imread(image_path)
  resized_img = cv2.resize(img, (224, 224))
  # Convert BGR to RGB (OpenCV loads images as BGR by default)
  img = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)
  # # Create a 2x4 grid for 8 images

  model_CAM = [GradCAM, ScoreCAM, GradCAMPlusPlus, AblationCAM, XGradCAM, EigenCAM]
  # model_CAM = [GradCAM, GradCAMPlusPlus, XGradCAM, EigenCAM]
  fig, axs = plt.subplots(1, 1+len(model_CAM), figsize=(10, 5))

  axs[0].imshow(img)
  axs[0].set_title(f"{result[0][0]} - {round(result[0][1], 4)}", fontsize=10)
  axs[0].axis('off')  # Hide axes

  # Load and display each image
  for i in range(len(model_CAM)):
      # Load the image (replace this with your image loading code)
      print(model_CAM[i])
      image = cam_func(img, target_layers, model_CAM[i])
      # Display the image
      axs[i+1].imshow(image)
      axs[i+1].set_title(f"{model_CAM[i].__name__}", fontsize=10)
      axs[i+1].axis('off')  # Hide axes

  # file_path = f'images/{file_paths[i]}'  # Change this to your desired file path
  
  write_to_file_three_times(log_file, f"iter: {i}")

  # Save the plot
  plt.savefig(f'{root_path}/images/ILSVRC2012/{file_names[i]}')
